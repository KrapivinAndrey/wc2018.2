#Использовать JSON

Перем Консоль;
Перем ПарсерJSON;
Перем НачалоИтерации;
Перем НомерИтерации;
Перем Отладка;

Перем Состояние;
Перем Ответ;
Перем Корабли;
Перем КораблиПротивника;
Перем РазмерКарты;
Перем ЭтоДрафт;

/////////////////////////////////////////////////////
// Сценарий

Процедура ВыполнитьСценарий()
	
	БлижайшийВраг 		 = БлижайшийВраг(Корабли[0]);
	БлижайшийВрагПозиция = НовыйВектор(БлижайшийВраг["Position"]);
	
	Для каждого Корабль из Корабли Цикл 
		
		Летим(Корабль, НовыйВектор(БлижайшийВрагПозиция.X , 0 , БлижайшийВрагПозиция.Z));
		
	КонецЦикла;	
	
	Отстреляться();

КонецПроцедуры

Процедура ВыполнитьСценарийДрафт()
	
	МассивКораблей = Новый Массив;
		
	Если Состояние["PlayerId"] = 0 Тогда 
		
		Корабликforward = Новый Соответствие;
		Корабликforward.Вставить("Position", "2/0/0");
		Корабликforward.Вставить("CompleteShipId", "forward");
		МассивКораблей.Добавить(Корабликforward);
		
		Корабликforward = Новый Соответствие;
		Корабликforward.Вставить("Position", "6/0/0");
		Корабликforward.Вставить("CompleteShipId", "forward");
		МассивКораблей.Добавить(Корабликforward);
		
		Корабликforward = Новый Соответствие;
		Корабликforward.Вставить("Position", "2/0/4");
		Корабликforward.Вставить("CompleteShipId", "forward");
		МассивКораблей.Добавить(Корабликforward);
		
		Корабликforward = Новый Соответствие;
		Корабликforward.Вставить("Position", "4/0/2");
		Корабликforward.Вставить("CompleteShipId", "forward");
		МассивКораблей.Добавить(Корабликforward);
		
		Корабликforward = Новый Соответствие;
		Корабликforward.Вставить("Position", "6/0/4");
		Корабликforward.Вставить("CompleteShipId", "forward");
		МассивКораблей.Добавить(Корабликforward);
	
	Иначе 
		
		Корабликforward = Новый Соответствие;
		Корабликforward.Вставить("Position", "28/0/0");
		Корабликforward.Вставить("CompleteShipId", "forward");
		МассивКораблей.Добавить(Корабликforward);
		
		Корабликforward = Новый Соответствие;
		Корабликforward.Вставить("Position", "24/0/0");
		Корабликforward.Вставить("CompleteShipId", "forward");
		МассивКораблей.Добавить(Корабликforward);
		
		Корабликforward = Новый Соответствие;
		Корабликforward.Вставить("Position", "28/0/4");
		Корабликforward.Вставить("CompleteShipId", "forward");
		МассивКораблей.Добавить(Корабликforward);
		
		Корабликforward = Новый Соответствие;
		Корабликforward.Вставить("Position", "26/0/2");
		Корабликforward.Вставить("CompleteShipId", "forward");
		МассивКораблей.Добавить(Корабликforward);
		
		Корабликforward = Новый Соответствие;
		Корабликforward.Вставить("Position", "24/0/2");
		Корабликforward.Вставить("CompleteShipId", "forward");
		МассивКораблей.Добавить(Корабликforward);
	
	КонецЕсли;
	
	ОтветDraft = Новый Соответствие;
	ОтветDraft.Вставить("Ships", МассивКораблей);
	
	ВалидныйОтветСтрока = ПарсерJSON.записатьJSON(ОтветDraft);
	ВалидныйОтветСтрока = СтрЗаменить(ВалидныйОтветСтрока, Символы.ПС, "");
	ВалидныйОтветСтрока = СтрЗаменить(ВалидныйОтветСтрока, " ", "");
	
	Консоль.ВывестиСтроку(ВалидныйОтветСтрока);

КонецПроцедуры

/////////////////////////////////////////////////////
// Процедуры и функции обработки сценария

#Область ПроцедурыИФункцииОбработкиСценария

Функция БлижайшийВраг(Корабль)
	
	ВекторКоординат = ПолучитьВекторКоординатКорабля(Корабль);
	minZ = 28;
	Для каждого Враг из КораблиПротивника Цикл 
		
		Если ПолучитьВекторКоординатКорабля(Враг).Y <= minZ Тогда 
			minZ = ПолучитьВекторКоординатКорабля(Враг).Y;
			НашВраг = Враг;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат НашВраг;
	
КонецФункции 

Функция ПолучитьРазрешенныйВыстрел(Корабль, Враг, Знач Орудие = Неопределено)
	
	Если Орудие = Неопределено Тогда
		Орудие = ОсновноеОрудиеКорабля(Корабль);
	КонецЕсли;
	
	ПоправкаНаСближение = 1;
	
	РасстояниеДоТекущейПозицииВрага = РасстояниеЧебышев(Корабль["Position"], Враг["Position"]);
	
	Если РасстояниеДоТекущейПозицииВрага > 5 Тогда
		ОжидаемоеПоложениеВрага = СуммаВекторов(Враг["Position"], Враг["Velocity"]);
	Иначе // в ближнем бою херачим ьез упреждения
		ОжидаемоеПоложениеВрага = Враг["Position"];
	КонецЕсли;
	ЦельВРадиусеПоражения = Орудие["Radius"] + ПоправкаНаСближение >= РасстояниеЧебышев(Корабль["Position"], ОжидаемоеПоложениеВрага);
	
	//Отладка.Добавить("R_" + ЦельВРадиусеПоражения);
	//Отладка.Добавить("D_" + РасстояниеЧебышев(Корабль["Position"], ОжидаемоеПоложениеВрага));
	//Отладка.Добавить("S_" + Корабль["Position"]);
	//Отладка.Добавить("E_" + Враг["Position"]);
	//Отладка.Добавить("O_" + ВекторСтрокой(ОжидаемоеПоложениеВрага));
	
	ДружественныйОгонь = ДружественныйОгонь(Корабль, ОжидаемоеПоложениеВрага);
	//ДружественныйОгонь = ложь;
	Если ЦельВРадиусеПоражения И Не ДружественныйОгонь Тогда
		Возврат Выстрел(Корабль, ОжидаемоеПоложениеВрага, Орудие);
	Иначе
		Возврат Неопределено;
	КонецЕсли
	
КонецФункции

Функция ДружественныйОгонь(Корабль, Цель)
	
	//ТочкаНачалаВыстрела = Корабль["Position"]; // по тупому
	ТочкаНачалаВыстрела = ТочкаНачалаВыстрела(Корабль, Цель); //по манхетонской метрике"
	
	ТочкиЛучаПоБрезенхему = ТочкиЛучаПоБрезенхему(ТочкаНачалаВыстрела, Цель);
	
	Для Каждого Союзник Из Корабли Цикл
		
		Если Корабль["Id"] = Союзник["Id"] Тогда
			Продолжить; // себе в ногу вроде не выстрелим
		КонецЕсли;
		
		ОжидаемеоеПоложениеСоюзника = СуммаВекторов(Союзник["Position"], Союзник["Velocity"]);
		//TODO добавить ускорение текущего хода. Должны его знать, так как сначала ходим потом стрелям
		
		ЦепляемСвоего = Ложь;
		Для Каждого Точка Из ТочкиЛучаПоБрезенхему Цикл
			//Если РасстояниеЧебышев(ОжидаемеоеПоложениеСоюзника, Точка) <= 1 Тогда
			Хуйня = Истина;
			
			Если НЕ (ОжидаемеоеПоложениеСоюзника.x - Точка.x = 0 или ОжидаемеоеПоложениеСоюзника.x - Точка.x = 1) Тогда
				Хуйня = Ложь;
			КонецЕсли;
			Если НЕ (ОжидаемеоеПоложениеСоюзника.y - Точка.y = 0 или ОжидаемеоеПоложениеСоюзника.y - Точка.y = 1) Тогда
				Хуйня = Ложь;
			КонецЕсли;
			Если НЕ (ОжидаемеоеПоложениеСоюзника.z - Точка.z = 0 или ОжидаемеоеПоложениеСоюзника.z - Точка.z = 1) Тогда
				Хуйня = Ложь;
			КонецЕсли;
			
			Если Хуйня Тогда 
				ЦепляемСвоего = Истина;
			КонецЕсли
		КонецЦикла;
		Если ЦепляемСвоего Тогда
			Возврат Истина;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

Функция ЦельАтаки()
	
	// 1 Выбрать самого дохлого
	ТЗКорабли = МассивСоответствийВТаблицуЗначений(КораблиПротивника);
	ТЗКорабли.Колонки.Добавить("Скорость");
	ТЗКорабли.Колонки.Добавить("Доступность");
	
	Для Каждого Строка Из ТЗКорабли Цикл
		Строка.Скорость = МодульВектора(Строка.Velocity);
		
		Строка.Доступность = 0;
		Для Каждого Союзник Из Корабли Цикл
			Если ПолучитьРазрешенныйВыстрел(Союзник, Строка.ИзначальноеСоответствие) <> Неопределено Тогда
				Строка.Доступность = Строка.Доступность + 1;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	ТЗКорабли.Сортировать("Доступность УБЫВ, Скорость ВОЗР, Health ВОЗР");
	//ОтсортированныеКорабли = ТаблицаЗначенийВМассивСоответствий(ТЗКорабли);
	
	Возврат ТЗКорабли[0].ИзначальноеСоответствие;
	
	// TODO 2 Среди самых дохлых выбрать самого доступного для наших кораблей
	
КонецФункции

Функция ТормознойПуть(Знач Скорость)
	
	Если Тип("Число") = ТипЗнч(Скорость) Тогда 
		Скорость = Скорость;
	ИначеЕсли Тип("Строка") = ТипЗнч(Скорость) Тогда
		Скорость = Число(Скорость);
	КонецЕсли;
	
	i = 1;
	j = 0;
	
	МодульСкорости = МодульЧисла(Скорость);
	
	Пока i <= МодульСкорости Цикл 
		j = j + i;
		i = i + 1;
	КонецЦикла;
	
	Возврат ?(Скорость < 0 , j * (-1), j);
	
КонецФункции

/////////////////////////////////////////////////////
// Лучи

Функция ТочкаНачалаВыстрела(Знач Корабль, Знач Цель)
	
	//Из правил: Бластер стреляет по цели из ближайшей (по манхэттенской метрике) точки корабля
	//Наблюдение: Корабль задается точкой с минимальными координатами (левой верхней)
	
	ТочкаНачалаВыстрела = НовыйВектор(Корабль["Position"]);
	ТочкаЦели = НовыйВектор(Корабль["Position"]);
	
	ЦельСправа = ТочкаНачалаВыстрела.x < ТочкаЦели.x;
	Если ЦельСправа Тогда
		ТочкаНачалаВыстрела.x = ТочкаНачалаВыстрела.x + 1;
	КонецЕсли;
	
	ЦельСверху = ТочкаНачалаВыстрела.y < ТочкаЦели.y;
	Если ЦельСверху Тогда
		ТочкаНачалаВыстрела.y = ТочкаНачалаВыстрела.y + 1;
	КонецЕсли;
	
	ЦельСбоку = ТочкаНачалаВыстрела.z < ТочкаЦели.z;
	Если ЦельСбоку Тогда // сам хз, с какого боку
		ТочкаНачалаВыстрела.z = ТочкаНачалаВыстрела.z + 1;
	КонецЕсли;
	
	Возврат ТочкаНачалаВыстрела;
	
КонецФункции

Функция ТочкиЛучаПоБрезенхему(Знач Начало, Знач Конец, ЭлементыСтроки = Ложь)
	
	Результат = Новый Массив;
	
	Начало = НовыйВектор(Начало);
	Конец = НовыйВектор(Конец);
	
	Координаты = Новый ТаблицаЗначений;
	Координаты.Колонки.Добавить("Имя");
	Координаты.Колонки.Добавить("Расстояние");
	
	Строка = Координаты.Добавить();
	Строка.Имя = "x";
	Строка.Расстояние = МодульЧисла(Начало.x - Конец.x);
	
	Строка = Координаты.Добавить();
	Строка.Имя = "y";
	Строка.Расстояние = МодульЧисла(Начало.y - Конец.y);
	
	Строка = Координаты.Добавить();
	Строка.Имя = "z";
	Строка.Расстояние = МодульЧисла(Начало.z - Конец.z);
	
	Координаты.Сортировать("Расстояние Убыв");	
	
	Если Начало[Координаты[0].Имя] > Конец[Координаты[0].Имя] Тогда
		Буфер = Начало;
		Начало = Конец;
		Конец = Буфер;
	КонецЕсли;
	
	КоличествоИтераций = Конец[Координаты[0].Имя] - Начало[Координаты[0].Имя];
	Если КоличествоИтераций = 0 Тогда
		
		Результат.Добавить(Начало);
		
		Если ЭлементыСтроки Тогда
			
			Для Сч = 0 По Результат.Количество() - 1 Цикл
				Результат[Сч] = ВекторСтрокой(Результат[Сч]);
			КонецЦикла;
			
		КонецЕсли;
		
		Возврат Результат;
		
	КонецЕсли;
	
	Смещение = Новый Соответствие;
	ТекущаяОшибка = Новый Соответствие;
	ТекущаяКоордината = Новый Соответствие;
	Направление = Новый Соответствие;
	Для ИндексКоординаты = 1 По 2 Цикл
		Смещение[ИндексКоординаты] = МодульЧисла(Конец[Координаты[ИндексКоординаты].Имя] - Начало[Координаты[ИндексКоординаты].Имя]) / КоличествоИтераций;
		ТекущаяОшибка[ИндексКоординаты] = 0;
		ТекущаяКоордината[ИндексКоординаты] = Начало[Координаты[ИндексКоординаты].Имя];		
		Направление[ИндексКоординаты] = Конец[Координаты[ИндексКоординаты].Имя] - Начало[Координаты[ИндексКоординаты].Имя];
		Направление[ИндексКоординаты] = ?(Направление[ИндексКоординаты] > 0, 1, -1);
	КонецЦикла;
	
	Для ГланаяКоордината = Начало[Координаты[0].Имя] По Конец[Координаты[0].Имя] Цикл
		
		НовыйВектор = НовыйВектор("0/0/0");
		НовыйВектор[Координаты[0].Имя] = ГланаяКоордината;
		
		Для ИндексКоординаты = 1 По 2 Цикл
			НовыйВектор[Координаты[ИндексКоординаты].Имя] = ТекущаяКоордината[ИндексКоординаты];
			ТекущаяОшибка[ИндексКоординаты] = ТекущаяОшибка[ИндексКоординаты] + Смещение[ИндексКоординаты];
			Если ТекущаяОшибка[ИндексКоординаты] >= 0.5 Тогда
				ТекущаяОшибка[ИндексКоординаты] = ТекущаяОшибка[ИндексКоординаты] - 1;
				ТекущаяКоордината[ИндексКоординаты] = ТекущаяКоордината[ИндексКоординаты] + Направление[ИндексКоординаты];
			КонецЕсли;
		КонецЦикла;
		
		Результат.Добавить(НовыйВектор);
		
	КонецЦикла;
	
	Если ЭлементыСтроки Тогда
		
		Для Сч = 0 По Результат.Количество() - 1 Цикл
			Результат[Сч] = ВекторСтрокой(Результат[Сч]);
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

/////////////////////////////////////////////////////
// Перемещение

Функция ВыехатьНаЦентр()

	ВекторСкорости 			 = "1/0/0";
	ВекторСкоростиТорможение = "-1/0/0"; 
	
	ПозцияКорабля1 = НовыйВектор(Корабли[0]["Position"]);

	Если ПозцияКорабля1.Y = 28 И ПозцияКорабля1.Z = 28 Тогда
		ВекторСкорости = "-1/28/28";
		ВекторСкоростиТорможение = "1/28/28";	
	КонецЕсли;

	Для Каждого Корабль Из Корабли Цикл

		Если НомерИтерации = 2 
			ИЛИ НомерИтерации = 3 Тогда

			Параметры = Новый Соответствие;
			Параметры.Вставить("Id"		, Корабль["Id"]);
			Параметры.Вставить("Vector" , ВекторСкорости);
	
			Команда = Новый Соответствие;
			Команда.Вставить("Command"	 , "ACCELERATE");
			Команда.Вставить("Parameters", Параметры);
			
			ДобавитьКоманду(Команда);

		ИначеЕсли НомерИтерации = 7
			ИЛИ НомерИтерации = 8  Тогда

			Параметры = Новый Соответствие;
			Параметры.Вставить("Id"		, Корабль["Id"]);
			Параметры.Вставить("Vector"	, ВекторСкоростиТорможение);
	
			Команда = Новый Соответствие;
			Команда.Вставить("Command"	 , "ACCELERATE");
			Команда.Вставить("Parameters", Параметры);

			ДобавитьКоманду(Команда);

		КонецЕсли;

	КонецЦикла;

КонецФункции

/////////////////////////////////////////////////////
// Стрельба
// 1. Расчитать таблицу для системы принятия решений, таблица содежит показатели доступности 
//	  и иные характеристикии для принятия решения
//	  - Инцииализировать коллекцию структруы (....)
//	  Для Каждого противника
//    - Расчитать доступность, как минимальное расстояние между ячейками кораблей не превышающее радиус поражения
//	  - 	Иначе продолжить
//	  - Расчитать лучи брезенхема для каждой точки внутри радиуса поражения, для иных точек (сформулированых эвистически)
//			Учитвая факт, что мы стрляем из ближайшей точки корабля к выбранной для поражения точки
//	  - Расчитать доступность точки, как луч пересекает противника (любого, цель) и не пересекает союзника
//	  - 	Иначе продолжить
//	  - Заполнить иные показатели для системы принятия решений (здоровье, скорость)
//
// Результом является коллекция, содержащая набор точек для стрельбы, гарантировано доступных, пересекающих противников и не пересекающих союзников
//
// 2. Принятие решения
//	Для Каждого Корабля
//	- Получить достпных себе противников
//  - Анализировать их достпность для товарищей
//	- Анализировать их иные характеристики
//	- Выбрать точку для стрельбы из достпных
//	- Принять решение

Процедура Отстреляться()
	
	СценарииСтрельбы = РасчитатьСценарииСтрельбы();
	ПриоритетныеЦели = ПриоритетныеЦели(СценарииСтрельбы);
	
	Для Каждого Корабль Из Корабли Цикл
		
		СценарииСтрельбыКорабля = ВыбратьСценарииСтрельбыКорабля(Корабль, ПриоритетныеЦели, СценарииСтрельбы);
		Если СценарииСтрельбыКорабля.Количество() = 0 Тогда
			Продолжить;
		КонецЕсли;

		//СценарииСтрельбыКорабля.Сортировать("ПопаданияВПротивников Убыв, КорабльПротивникаЗдоровье, КорабльПротивникаСкоростьЗначение");
		СценарииСтрельбыКорабля.Сортировать("ПопаданияВПротивников Убыв, ВыстрелРасстояние, КорабльПротивникаСкоростьЗначение");

		ВыбраныйВыстрел = СценарииСтрельбыКорабля[0];

		Отладка.Добавить("_shoot_" + 
			ВыбраныйВыстрел.КорабльИдентификатор + "-" + 
			ВыбраныйВыстрел.КорабльПротивникаИдентификатор + "-" + 
			ВекторСтрокой(ВыбраныйВыстрел.КорабльПротивникаПозиция));

		Для Каждого Орудие Из ОрудияКорабля(Корабль) Цикл
			Выстрел = Выстрел(Корабль, ВыбраныйВыстрел.ВыстрелТочка, Орудие);
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

Функция ВыбратьСценарииСтрельбыКорабля(Корабль, ПриоритетныеЦелиГлобальные, СценарииСтрельбы)
	
	Отбор = Новый Структура("КорабльИдентификатор, КорабльПротивникаИдентификатор");
	Отбор.КорабльИдентификатор = Корабль["Id"];
	
	// Поиск глобальных целей в сценариях
	
	СценарииСтрельбыКорабляГлобальные = СценарииСтрельбы.СкопироватьКолонки();
	
	Для Каждого Цель Из ПриоритетныеЦелиГлобальные Цикл		
		
		Отбор.КорабльПротивникаИдентификатор = Цель["Id"];
		
		СценарииСтрельбыКорабляГлобальные = СценарииСтрельбы.Скопировать(Отбор);		
		Если СценарииСтрельбыКорабляГлобальные.Количество() <> 0 Тогда
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Если СценарииСтрельбыКорабляГлобальные.Количество() <> 0 Тогда
		Возврат СценарииСтрельбыКорабляГлобальные;
	КонецЕсли;
	
	// Поиск локальных целей
	
	СценарииСтрельбыКорабляЛокальные = СценарииСтрельбы.СкопироватьКолонки();	
	
	Для Каждого Цель Из ПриоритетныеЦелиКорабля(Корабль, СценарииСтрельбы) Цикл		
		
		Отбор.КорабльПротивникаИдентификатор = Цель["Id"];
		
		СценарииСтрельбыКорабляЛокальные = СценарииСтрельбы.Скопировать(Отбор);		
		Если СценарииСтрельбыКорабляЛокальные.Количество() <> 0 Тогда
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Если СценарииСтрельбыКорабляЛокальные.Количество() <> 0 Тогда
		Возврат СценарииСтрельбыКорабляЛокальные;
	КонецЕсли;
	
	// Выбор из доступных целей
	
	Отбор.Удалить("КорабльПротивникаИдентификатор");
	
	СценарииСтрельбыКорабля = СценарииСтрельбы.Скопировать(Отбор);
	
	Возврат СценарииСтрельбыКорабля; 
	
КонецФункции

Функция ПриоритетныеЦели(СценарииСтрельбы)
	
	ПриоритетныеЦели = Новый Массив;
	
	// Функция возвращает массив кораблей противника, отсортированый в порядке приоритета
	
	ПоказателиПриоритетнойЦели = Новый ТаблицаЗначений;
	ПоказателиПриоритетнойЦели.Колонки.Добавить("КорабльПротивника");
	ПоказателиПриоритетнойЦели.Колонки.Добавить("КорабльПротивникаИдентификатор");
	ПоказателиПриоритетнойЦели.Колонки.Добавить("КорабльПротивникаЗдоровье");
	ПоказателиПриоритетнойЦели.Колонки.Добавить("КорабльПротивникаСкорость");
	ПоказателиПриоритетнойЦели.Колонки.Добавить("ДоступенСоюзникам");
	
	// Расчет показателей принятия решения, приоритетная цель
	
	Для Каждого Корабль Из КораблиПротивника Цикл
		
		Отбор = Новый Структура;
		Отбор.Вставить("КорабльПротивникаИдентификатор", Корабль["Id"]);
		
		ДостпностьСоюзникам = СценарииСтрельбы.Скопировать(Отбор, "КорабльИдентификатор");	
		ДостпностьСоюзникам.Свернуть("КорабльИдентификатор");
		
		НоваяСтрока = ПоказателиПриоритетнойЦели.Добавить();
		НоваяСтрока.КорабльПротивника 			   = Корабль;
		НоваяСтрока.КорабльПротивникаИдентификатор = Корабль["Id"];
		НоваяСтрока.КорабльПротивникаЗдоровье 	   = Корабль["Health"];
		НоваяСтрока.КорабльПротивникаСкорость 	   = СкоростьКорабля(Корабль);
		НоваяСтрока.ДоступенСоюзникам 			   = ДостпностьСоюзникам.Количество();
		
	КонецЦикла;
	
	ПоказателиПриоритетнойЦели.Сортировать("ДоступенСоюзникам Убыв");
	
	// Указываем цель, как глобальную если она доступна всем кроме одного союзника
	
	Если ПоказателиПриоритетнойЦели[0].ДоступенСоюзникам >= Корабли.Количество() - 1 Тогда
		ПриоритетныеЦели.Добавить(ПоказателиПриоритетнойЦели[0].КорабльПротивника);
	КонецЕсли;
	
	Возврат ПриоритетныеЦели;
	
КонецФункции

Функция ПриоритетныеЦелиКорабля(Корабль, СценарииСтрельбы)
	
	ПриоритетныеЦели = Новый Массив;
	
	// Функция возвращает массив кораблей противника, отсортированый в порядке приоритета
	
	Отбор = Новый Структура;
	Отбор.Вставить("КорабльИдентификатор", Корабль["Id"]);
	
	СценарииСтрельбыКорабля = СценарииСтрельбы.Скопировать(Отбор);	
	СценарииСтрельбыКорабля.Сортировать("ВыстрелРасстояние");
	
	// Приоритет выстрелу в упор
	
	Если СценарииСтрельбыКорабля.Количество() <> 0 Тогда
		Если СценарииСтрельбыКорабля[0].ВыстрелРасстояние <= 1 Тогда
			ПриоритетныеЦели.Добавить(СценарииСтрельбыКорабля[0].КорабльПротивника);
		КонецЕсли;
	КонецЕсли;
	
	Возврат ПриоритетныеЦели;
	
КонецФункции

Функция РасчитатьСценарииСтрельбы()
	
	// Функция возвращает аналитику возможных выстрелов каждого корабля в каждого доступного противника
	
	СценарииСтрельбы = Новый ТаблицаЗначений;
	СценарииСтрельбы.Колонки.Добавить("Корабль");
	СценарииСтрельбы.Колонки.Добавить("КорабльИдентификатор");
	СценарииСтрельбы.Колонки.Добавить("КорабльПротивника");
	СценарииСтрельбы.Колонки.Добавить("КорабльПротивникаИдентификатор");
	СценарииСтрельбы.Колонки.Добавить("КорабльПротивникаЗдоровье");
	СценарииСтрельбы.Колонки.Добавить("КорабльПротивникаПозиция");
	СценарииСтрельбы.Колонки.Добавить("КорабльПротивникаСкорость");
	СценарииСтрельбы.Колонки.Добавить("КорабльПротивникаСкоростьЗначение");
	СценарииСтрельбы.Колонки.Добавить("Выстрел");
	СценарииСтрельбы.Колонки.Добавить("ВыстрелТочка");
	СценарииСтрельбы.Колонки.Добавить("ВыстрелЯчейкаКорабля");
	СценарииСтрельбы.Колонки.Добавить("ВыстрелРасстояние");
	СценарииСтрельбы.Колонки.Добавить("ПопаданияВПротивника");
	СценарииСтрельбы.Колонки.Добавить("ПопаданияВПротивников");
	
	КоординатыКораблей			  = КоординатыКораблей();
	КоординатыКораблейПротивников = КоординатыКораблейПротивников();
	
	Для Каждого Корабль Из Корабли Цикл
		
		Для Каждого КорабльПротивника Из КораблиПротивника Цикл	
			
			// Расчет сценария стрельбы для корабля
			
			СценарийСтрельбыКорабля = РасчитатьСценарийСтрельбы(Корабль, 
			КорабльПротивника, 
			КоординатыКораблей, 
			КоординатыКораблейПротивников);
			
			Если СценарийСтрельбыКорабля = Неопределено Тогда
				продолжить;
			КонецЕсли;
			
			// Наполнение общего сценария
			
			Для Каждого Элемент Из СценарийСтрельбыКорабля Цикл
				ЗаполнитьЗначенияСвойств(СценарииСтрельбы.Добавить(), Элемент);
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат СценарииСтрельбы;
	
КонецФункции

Функция РасчитатьСценарийСтрельбы(Корабль, КорабльПротивника, КоординатыКораблей, КоординатыКораблейПротивников)
	
	Орудие 					 = ОсновноеОрудиеКорабля(Корабль);
	КорабльПозиция 			 = ПозицияКорабля(Корабль);
	КорабльПротивникаПозиция = ПозицияКорабля(КорабльПротивника);
	
	// Расчитать доступность, как минимальное расстояние между ячейками кораблей не превышающее радиус поражения
	
	Расстояние = РасстояниеМеждуКораблямиОбъект(КорабльПозиция, КорабльПротивникаПозиция);
	Если Расстояние.Значение > Орудие["Radius"] Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Расчитать лучи брезенхема для каждой точки внутри радиуса поражения, для иных точек (сформулированых эвистически)
	// Учитвая факт, что мы стрляем из ближайшей точки корабля к выбранной для поражения точки
	
	СценарийСтрельбы = Новый Массив();
	
	// Расчет лучей во все координаты противника слишком затратно
	// сделаем выбор для 3х точек  
	//МКПротивника = МассивКоординатКорабля(КорабльПротивникаПозиция, Истина);
	
	МКПротивника = Новый Массив;
	МКПротивника.Добавить(ВекторСтрокой(Расстояние.ЯчейкаКорабля2));
	МКПротивника.Добавить(ВекторСтрокой(Расстояние.МаксЯчейкаКорабля2));
	МКПротивника.Добавить(ВекторСтрокой(Расстояние.МаксБЯчейкаКорабля2));
	
	Для Каждого ЯчейкаКорабляПротивника Из МКПротивника Цикл
		
		ВыстрелЛуч = РасчитатьВыстрелЛуч(Орудие, КорабльПозиция, ЯчейкаКорабляПротивника);
		Если ВыстрелЛуч = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		// Луч равный нулю можно получить если ожидается, что корабли окажутся в одной точке, 
		// ожидается столкновение
		// TODO Нужно как-то обрабатывать такой кейс, устанавливая новое предполагаемое положение противника
		// в процедуре Положение корабля или тут
		
		Если ВыстрелЛуч.Луч.Количество() = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		// Расчитать доступность точки, как луч пересекает противника (любого, цель) и не пересекает союзника
		// Иначе продолжить
		
		ПопаданияВСоюзников = РасчитатьПересеченияВыстрелаЛучаСМассивомКоординатКораблей(ВыстрелЛуч.Луч, КоординатыКораблей);
		Если ПопаданияВСоюзников > 0 Тогда
			Продолжить;
		КонецЕсли;
		
		ПопаданияВПротивников = РасчитатьПересеченияВыстрелаЛучаСМассивомКоординатКораблей(ВыстрелЛуч.Луч, КоординатыКораблейПротивников);
		ПопаданияВПротивника  = РасчитатьПересеченияВыстрелаЛучаСМассивомКоординатКораблей(ВыстрелЛуч.Луч, МКПротивника);
		
		// Если луч не попадает в цель, то что-то пошло не так
		
		Если ПопаданияВПротивника = 0 Тогда
			ВызватьИсключение "shit shot";
		КонецЕсли;
		
		// Запись показателей стрельбы
		
		ЭлементСценарияСтрельбы = Новый Структура;
		ЭлементСценарияСтрельбы.Вставить("Корабль"			   , Корабль);
		ЭлементСценарияСтрельбы.Вставить("КорабльИдентификатор", Корабль["Id"]);
		
		ЭлементСценарияСтрельбы.Вставить("КорабльПротивника"			    , КорабльПротивника);
		ЭлементСценарияСтрельбы.Вставить("КорабльПротивникаИдентификатор"   , КорабльПротивника["Id"]);
		ЭлементСценарияСтрельбы.Вставить("КорабльПротивникаЗдоровье"	    , КорабльПротивника["Health"]);
		ЭлементСценарияСтрельбы.Вставить("КорабльПротивникаПозиция"	    	, ВекторСтрокой(КорабльПротивникаПозиция));
		ЭлементСценарияСтрельбы.Вставить("КорабльПротивникаСкорость"	    , СкоростьКорабля(КорабльПротивника));		
		ЭлементСценарияСтрельбы.Вставить("КорабльПротивникаСкоростьЗначение");
		
		ЭлементСценарияСтрельбы.Вставить("Выстрел" 			    , ВыстрелЛуч);
		ЭлементСценарияСтрельбы.Вставить("ВыстрелТочка"			, ВыстрелЛуч.Точка);
		ЭлементСценарияСтрельбы.Вставить("ВыстрелЯчейкаКорабля" , ВыстрелЛуч.ЯчейкаКорабля);
		ЭлементСценарияСтрельбы.Вставить("ВыстрелРасстояние"	, ВыстрелЛуч.Расстояние);
		ЭлементСценарияСтрельбы.Вставить("ПопаданияВПротивника"	, ПопаданияВПротивника);
		ЭлементСценарияСтрельбы.Вставить("ПопаданияВПротивников", ПопаданияВПротивников);
		
		ЭлементСценарияСтрельбы.КорабльПротивникаСкоростьЗначение = 
		МодульЧисла(ЭлементСценарияСтрельбы.КорабльПротивникаСкорость.X)
		+ МодульЧисла(ЭлементСценарияСтрельбы.КорабльПротивникаСкорость.Y)
		+ МодульЧисла(ЭлементСценарияСтрельбы.КорабльПротивникаСкорость.Z);	
		
		СценарийСтрельбы.Добавить(ЭлементСценарияСтрельбы);
		
	КонецЦикла;
	
	Возврат СценарийСтрельбы;
	
КонецФункции

Функция РасчитатьВыстрелЛуч(Орудие, КорабльПозиция, Точка)
	
	ВыстрелЛуч = Новый Структура;
	ВыстрелЛуч.Вставить("Луч");
	ВыстрелЛуч.Вставить("Расстояние");
	ВыстрелЛуч.Вставить("ЯчейкаКорабля");
	ВыстрелЛуч.Вставить("Точка");
	
	// Расстояние между ближайшей точкой нашего корабля и заданой точкой (модулем корабля противника)
	
	Расстояние = РасстояниеМеждуКорабльИПозиция(КорабльПозиция, Точка);
	Если Расстояние.Значение > Орудие["Radius"] Тогда
		Возврат Неопределено;
	КонецЕсли;	
	
	// Луч брезенхема из ближайшей точки корабля в указаную
	
	Луч = ТочкиЛучаПоБрезенхему(Расстояние.ЯчейкаКорабля, Точка, Истина);
	Если Луч.Количество() = 0 Тогда
		ВызватьИсключение "Опаньки";
	КонецЕсли;
	
	// Удалим точку нашего коробля	
	
	ИндексЯчейкиКорабля = Луч.Найти(ВекторСтрокой(Расстояние.ЯчейкаКорабля));
	
	Если ИндексЯчейкиКорабля = Неопределено Тогда
		ВызватьИсключение "Что-то пошло не так";	
	КонецЕсли;
	
	Луч.Удалить(ИндексЯчейкиКорабля);
	
	// Удалим точки луча, что не нанесут урон
	
	Пока Луч.Количество() > Орудие["Radius"] Цикл
		Луч.Удалить(Луч.Количество() - 1);
	КонецЦикла;
	
	ВыстрелЛуч = Новый Структура;
	ВыстрелЛуч.Вставить("Луч"			, Луч);
	ВыстрелЛуч.Вставить("Точка"			, Точка);
	ВыстрелЛуч.Вставить("Расстояние"	, Расстояние.Значение);
	ВыстрелЛуч.Вставить("ЯчейкаКорабля"	, Расстояние.ЯчейкаКорабля);
	
	Возврат ВыстрелЛуч;
	
КонецФункции

Функция РасчитатьПересеченияВыстрелаЛучаСМассивомКоординатКораблей(ВыстрелЛуч, МассивКоординатКораблей)
	
	КоличествоПересечений = 0;
	
	Для Каждого МодульКорабля Из МассивКоординатКораблей Цикл
		Если ВыстрелЛуч.Найти(МодульКорабля) <> Неопределено Тогда
			КоличествоПересечений = КоличествоПересечений + 1;	
		КонецЕсли
	КонецЦикла;
	
	Возврат КоличествоПересечений;
	
КонецФункции

/////////////////////////////////////////////////////
// Функции связаные с кораблем

Функция РазмерКартыДляКорабля(Корабль)
	Возврат Число(РазмерКарты - 2) ; // Заменить 2 на Корабль["Size???"] 
КонецФункции

Функция ОсновноеОрудиеКорабля(Корабль)
	
	Оборудование = Корабль["Equipment"];
	
	Для Каждого Элемент Из Оборудование Цикл
		
		Если Элемент["Type"] = 1 Тогда
			Возврат Элемент;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Неопределено;	
	
КонецФункции

Функция ОрудияКорабля(Корабль)

	ОрудияКорабля = Новый Массив();

	Оборудование = Корабль["Equipment"];
	
	Для Каждого Элемент Из Оборудование Цикл		
		Если Элемент["Type"] = 1 Тогда
			ОрудияКорабля.Добавить(Элемент);	
		КонецЕсли;		
	КонецЦикла;
	
	Возврат ОрудияКорабля;
	
КонецФункции

Функция ДвигательКорабля(Корабль)
	
	Оборудование = Корабль["Equipment"];
	
	Для Каждого Элемент Из Оборудование Цикл
		
		Если Элемент["Type"] = 2 Тогда
			Возврат Элемент;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

Функция НачальнаяПозицияКорабля(Корабль)
	
	ПоцияКОтступлению = НовыйВектор(0, 0, 0);
	
	УголИгрока1 = Истина;
	
	Попытка
		ПорядковыйНомер = Число(Корабль["Id"]);
		Если ПорядковыйНомер >= 10000 Тогда
			ПорядковыйНомер = ПорядковыйНомер - 10000;
			УголИгрока1 = Ложь;
		КонецЕсли;
	Исключение
		ПорядковыйНомер = 0;
	КонецПопытки;
	
	Если УголИгрока1 Тогда
		ПоцияКОтступлению = НовыйВектор(ПорядковыйНомер * 2, 0, 0);	
	Иначе
		ПоцияКОтступлению = НовыйВектор(20 + (ПорядковыйНомер * 2), 28, 28);	
	КонецЕсли;
	
	Возврат ПоцияКОтступлению;
	
КонецФункции

Функция ПолучитьВекторСкоростиКорабля(Корабль)
	Возврат НовыйВектор(Корабль["Velocity"]);
КонецФункции

Функция СкоростьКорабля(Корабль, Педполагаемая = Истина)
	
	Если Корабль = Неопределено
		ИЛИ Корабль["Id"] = Неопределено 
		ИЛИ Корабль["Velocity"] = Неопределено Тогда
		ВызватьИсключение "Непредполагаемое значение параметра №1";
	КонецЕсли;
	
	СкоростьКорабля = НовыйВектор(Корабль["Velocity"]);
	
	Если Педполагаемая = Истина Тогда
		
		// Для своих кораблей
		
		Для Каждого Команда Из Ответ["UserCommands"] Цикл
			
			Если Команда["Command"] = "ACCELERATE"
				И Команда["Parameters"]["Id"] = Корабль["Id"] Тогда
				ВекторУскорения = НовыйВектор(Команда["Parameters"]["Vector"]);
				СкоростьКорабля = СуммаВекторов(СкоростьКорабля, ВекторУскорения);
				Прервать;
			КонецЕсли
			
		КонецЦикла;
		
		// TODO Для чужих, можно учитвать ограничения тормозного пути
		
	КонецЕсли;
	
	Возврат СкоростьКорабля;
	
КонецФункции

Функция ПозицияКорабля(Корабль, Педполагаемая = Истина)
	
	Если Корабль = Неопределено
		ИЛИ Корабль["Id"] = Неопределено 
		ИЛИ Корабль["Velocity"] = Неопределено Тогда
		ВызватьИсключение "Непредполагаемое значение параметра №1";
	КонецЕсли;
	
	ПозицияКорабля = НовыйВектор(Корабль["Position"]);
	
	Если Педполагаемая = Истина Тогда
		
		СкоростьКорабля = СкоростьКорабля(Корабль, Педполагаемая);
		ПозицияКорабля  = СуммаВекторов(ПозицияКорабля, СкоростьКорабля);
		
	КонецЕсли;
	
	Возврат ПозицияКорабля;
	
КонецФункции

Функция ПозицияКорабляМассивКоординат(Корабль, Педполагаемая = Истина)
	
	// Функция возвращает массив всех координат корабля
	
	ПозицияКорабля = ПозицияКорабля(Корабль, Педполагаемая);
	
	Возврат МассивКоординатКорабля(ПозицияКорабля);
	
КонецФункции

Функция МассивКоординатКорабля(Знач ПозицияКорабля, ЭлементыСтроки = Ложь)
	
	//	Функция получает все координаты корабля, по его позиции согласно вводу
	
	Если ТипЗнч(ПозицияКорабля) = Тип("Строка") Тогда
		ПозицияКорабля = НовыйВектор(ПозицияКорабля);
	КонецЕсли;
	
	МассивКоординат = Новый Массив;
	МассивКоординат.Добавить(ПозицияКорабля);
	МассивКоординат.Добавить(НовыйВектор(ПозицияКорабля.X + 1, ПозицияКорабля.Y   , ПозицияКорабля.Z	));
	МассивКоординат.Добавить(НовыйВектор(ПозицияКорабля.X 	 , ПозицияКорабля.Y +1, ПозицияКорабля.Z	));
	МассивКоординат.Добавить(НовыйВектор(ПозицияКорабля.X + 1, ПозицияКорабля.Y +1, ПозицияКорабля.Z	));
	МассивКоординат.Добавить(НовыйВектор(ПозицияКорабля.X    , ПозицияКорабля.Y   , ПозицияКорабля.Z + 1));
	МассивКоординат.Добавить(НовыйВектор(ПозицияКорабля.X + 1, ПозицияКорабля.Y   , ПозицияКорабля.Z + 1));
	МассивКоординат.Добавить(НовыйВектор(ПозицияКорабля.X 	 , ПозицияКорабля.Y +1, ПозицияКорабля.Z + 1));
	МассивКоординат.Добавить(НовыйВектор(ПозицияКорабля.X + 1, ПозицияКорабля.Y +1, ПозицияКорабля.Z + 1));
	
	Если ЭлементыСтроки Тогда
		
		Для Сч = 0 По МассивКоординат.Количество() - 1 Цикл
			МассивКоординат[СЧ] = ВекторСтрокой(МассивКоординат[Сч]);
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат МассивКоординат;
	
КонецФункции

Функция РасстояниеМеждуКораблямиОбъект(Знач ПозицияКорабля1, Знач ПозицияКорабля2)
	
	//	Функция расчитывает расстояние между кораблями, как сложными объектами
	//  возвращает:
	//	1. минимальное значение расстояния и координаты ближайших точек,
	//  2. максимальное значение расстояния и координаты дальних точек
	//  Вычисленные точки могут использоваться в сценариях стрельбы и целеуказания
	
	Если ТипЗнч(ПозицияКорабля1) = Тип("Строка") Тогда
		ПозицияКорабля1 = НовыйВектор(ПозицияКорабля1);
	КонецЕсли;
	
	Если ТипЗнч(ПозицияКорабля2) = Тип("Строка") Тогда
		ПозицияКорабля2 = НовыйВектор(ПозицияКорабля2);
	КонецЕсли;
	
	// Массивы координат объектов
	
	МассивКоординатКорабля1 = МассивКоординатКорабля(ПозицияКорабля1);
	МассивКоординатКорабля2 = МассивКоординатКорабля(ПозицияКорабля2);
	
	ТаблицаРезультатов = Новый ТаблицаЗначений;
	ТаблицаРезультатов.Колонки.Добавить("Расстояние");	
	ТаблицаРезультатов.Колонки.Добавить("ЯчейкаКорабля1");
	ТаблицаРезультатов.Колонки.Добавить("ЯчейкаКорабля2");
	
	// Расчитаем расстояние ячеек кораблей друг от дурга
	
	Для Каждого ЯчейкаКорабля1 Из МассивКоординатКорабля1 Цикл
		
		Для Каждого ЯчейкаКорабля2 Из МассивКоординатКорабля2 Цикл
			
			НоваяСтрока = ТаблицаРезультатов.Добавить(); 
			НоваяСтрока.ЯчейкаКорабля1 = ЯчейкаКорабля1;
			НоваяСтрока.ЯчейкаКорабля2 = ЯчейкаКорабля2;
			НоваяСтрока.Расстояние	   = РасстояниеЧебышев(ЯчейкаКорабля1, ЯчейкаКорабля2);
			
		КонецЦикла;		
		
	КонецЦикла;
	
	// Формирование объекта результата
	
	Если ТаблицаРезультатов.Количество() = 0 Тогда
		ВызватьИсключение "Опаньки";
	КонецЕсли;
	
	РасстояниеМеждуКораблями = Новый Структура;
	
	// Минимальное расстояние
	
	ТаблицаРезультатов.Сортировать("Расстояние");
	
	РасстояниеМеждуКораблями.Вставить("Значение"	  , ТаблицаРезультатов[0].Расстояние);
	РасстояниеМеждуКораблями.Вставить("ЯчейкаКорабля1", ТаблицаРезультатов[0].ЯчейкаКорабля1);
	РасстояниеМеждуКораблями.Вставить("ЯчейкаКорабля2", ТаблицаРезультатов[0].ЯчейкаКорабля2);
	
	// Максимальное расстояние
	
	ТаблицаРезультатов.Сортировать("Расстояние УБЫВ");
	
	РасстояниеМеждуКораблями.Вставить("МаксЗначение"      , ТаблицаРезультатов[0].Расстояние);
	РасстояниеМеждуКораблями.Вставить("МаксЯчейкаКорабля1", ТаблицаРезультатов[0].ЯчейкаКорабля1);
	РасстояниеМеждуКораблями.Вставить("МаксЯчейкаКорабля2", ТаблицаРезультатов[0].ЯчейкаКорабля2);
	
	// Максимальное от ближайшей ячейки
	
	РасстояниеМеждуКораблями.Вставить("МаксБЗначение"      , РасстояниеМеждуКораблями.Значение);
	РасстояниеМеждуКораблями.Вставить("МаксБЯчейкаКорабля1", РасстояниеМеждуКораблями.ЯчейкаКорабля1);
	РасстояниеМеждуКораблями.Вставить("МаксБЯчейкаКорабля2", РасстояниеМеждуКораблями.ЯчейкаКорабля2);
	
	Для Каждого ЯчейкаКорабля2 Из МассивКоординатКорабля2 Цикл
		Расстояние = РасстояниеЧебышев(РасстояниеМеждуКораблями.ЯчейкаКорабля1, ЯчейкаКорабля2);
		Если Расстояние > РасстояниеМеждуКораблями.МаксБЗначение Тогда
			РасстояниеМеждуКораблями.МаксБЗначение        = Расстояние;
			РасстояниеМеждуКораблями.МаксБЯчейкаКорабля2  = НовыйВектор(ЯчейкаКорабля2);
		КонецЕсли;
	КонецЦикла;
	
	Возврат РасстояниеМеждуКораблями;
	
КонецФункции

Функция РасстояниеМеждуКорабльИПозиция(Знач ПозицияКорабля, Знач Позиция)
	
	//	Функция расчитывает расстояние между кораблем и точкой в системе координта
	
	Если ТипЗнч(ПозицияКорабля) = Тип("Строка") Тогда
		ПозицияКорабля = НовыйВектор(ПозицияКорабля);
	КонецЕсли;
	
	Если ТипЗнч(Позиция) = Тип("Строка") Тогда
		Позиция = НовыйВектор(Позиция);
	КонецЕсли;
	
	// Массивы координат объектов
	
	МассивКоординатКорабля = МассивКоординатКорабля(ПозицияКорабля);
	
	ТаблицаРезультатов = Новый ТаблицаЗначений;
	ТаблицаРезультатов.Колонки.Добавить("Расстояние");	
	ТаблицаРезультатов.Колонки.Добавить("ЯчейкаКорабля");
	
	// Расчитаем расстояние ячеек кораблей друг от дурга
	
	Для Каждого ЯчейкаКорабля Из МассивКоординатКорабля Цикл
		
		НоваяСтрока = ТаблицаРезультатов.Добавить(); 
		НоваяСтрока.ЯчейкаКорабля = ЯчейкаКорабля;
		НоваяСтрока.Расстояние    = РасстояниеЧебышев(ЯчейкаКорабля, Позиция);		
		
	КонецЦикла;
	
	// Формирование объекта результата
	
	Если ТаблицаРезультатов.Количество() = 0 Тогда
		ВызватьИсключение "Опаньки";
	КонецЕсли;
	
	// Минимальное расстояние
	
	ТаблицаРезультатов.Сортировать("Расстояние");
	
	РасстояниеМеждуКораблями = Новый Структура;
	РасстояниеМеждуКораблями.Вставить("Значение"	 , ТаблицаРезультатов[0].Расстояние);
	РасстояниеМеждуКораблями.Вставить("ЯчейкаКорабля", ТаблицаРезультатов[0].ЯчейкаКорабля);
	
	Возврат РасстояниеМеждуКораблями;
	
КонецФункции

Функция ПолучитьВекторКоординатКорабля(Корабль)
	Возврат НовыйВектор(Корабль["Position"]);
КонецФункции

Функция КорабльНаш(Корабль)
	Возврат (Корабль["Equipment"] <> Неопределено);
КонецФункции

Функция МаксимальноеУскорениеНашегоКорабля(Корабль)
	Двигатель = ДвигательКорабля(Корабль);
	Возврат Число(Двигатель["MaxAccelerate"]);
КонецФункции

Функция МаксимальноеУскорениеВражескогоКорабля(Корабль)
	Возврат 1;
КонецФункции

Функция КритичнаяСкорость(Корабль, Скорость = Неопределено)
	
	КорабльНаш 			    = КорабльНаш(Корабль);
	КоординатыКорабля 	    = ПолучитьВекторКоординатКорабля(Корабль);
	Скорость		    	= ?(Скорость = Неопределено , ПолучитьВекторСкоростиКорабля(Корабль) , НовыйВектор(Скорость));
	МаксимальноеУскорение   = ?(КорабльНаш, МаксимальноеУскорениеНашегоКорабля(Корабль), МаксимальноеУскорениеВражескогоКорабля(Корабль));
	
	X = МинимальнаяКонечнаяКоординатаТормозногоПути(КоординатыКорабля.X, Скорость.X, МаксимальноеУскорение);
	Y = МинимальнаяКонечнаяКоординатаТормозногоПути(КоординатыКорабля.Y, Скорость.Y, МаксимальноеУскорение);
	Z = МинимальнаяКонечнаяКоординатаТормозногоПути(КоординатыКорабля.Z, Скорость.Z, МаксимальноеУскорение);
	
	Если КритичнаяТочкаДляКорабля(Корабль, X) Тогда 
		Возврат Истина;
	КонецЕсли;
	Если КритичнаяТочкаДляКорабля(Корабль, Y) Тогда 
		Возврат Истина;
	КонецЕсли;
	Если КритичнаяТочкаДляКорабля(Корабль, Z) Тогда 
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

Функция КритичноеУскорение(Корабль, ВекторУскорения) 
	
	КорабльНаш 			    = КорабльНаш(Корабль);
	КоординатыКорабля 	    = ПолучитьВекторКоординатКорабля(Корабль);
	ВекторУскорения 		= НовыйВектор(ВекторУскорения);
	СкоростьКорабля		    = ПолучитьВекторСкоростиКорабля(Корабль);
	МаксимальноеУскорение   = ?(КорабльНаш, МаксимальноеУскорениеНашегоКорабля(Корабль), МаксимальноеУскорениеВражескогоКорабля(Корабль));
	
	X = МинимальнаяКонечнаяКоординатаТормозногоПути(КоординатыКорабля.X + СкоростьКорабля.X + ВекторУскорения.X, СкоростьКорабля.X + ВекторУскорения.X, МаксимальноеУскорение);
	Y = МинимальнаяКонечнаяКоординатаТормозногоПути(КоординатыКорабля.Y + СкоростьКорабля.Y + ВекторУскорения.Y, СкоростьКорабля.Y + ВекторУскорения.Y, МаксимальноеУскорение);
	Z = МинимальнаяКонечнаяКоординатаТормозногоПути(КоординатыКорабля.Z + СкоростьКорабля.Z + ВекторУскорения.Z, СкоростьКорабля.Z + ВекторУскорения.Z, МаксимальноеУскорение);
	
	Если КритичнаяТочкаДляКорабля(Корабль, X) Тогда
		Возврат Истина;
	КонецЕсли;
	Если КритичнаяТочкаДляКорабля(Корабль, Y) Тогда
		Возврат Истина;
	КонецЕсли;
	Если КритичнаяТочкаДляКорабля(Корабль, Z) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

Функция МинимальнаяКонечнаяКоординатаТормозногоПути(Знач Координата, Знач Скорость, Знач МаксУскорение)
	
	Если Скорость > 0 Тогда 
		Пока НЕ Скорость <=0 Цикл
			Координата = Координата + (Скорость - МаксУскорение);
			Скорость = Скорость - МаксУскорение;
		КонецЦикла;
	КонецЕсли;
	
	Если Скорость < 0 Тогда 
		Пока НЕ Скорость >= 0 Цикл
			Координата = Координата + (Скорость + МаксУскорение);
			Скорость = Скорость + МаксУскорение;
		КонецЦикла;
	КонецЕсли;
	
	Возврат Число(Координата) ;
КонецФункции

Функция ПолучитьВекторУскорения(Корабль, Цель)
	КоординатыЦели			= НовыйВектор(Цель);
	КоординатыКорабля 	    = ПолучитьВекторКоординатКорабля(Корабль);
	
	X = ?(КоординатыКорабля.X < КоординатыЦели.X , 1 , -1); 
	Y = ?(КоординатыКорабля.Y < КоординатыЦели.Y , 1 , -1); 
	Z = ?(КоординатыКорабля.Z < КоординатыЦели.Z , 1 , -1); 
	
	Если КоординатыКорабля.X = КоординатыЦели.X Тогда 
		X = 0;
	КонецЕсли;
	Если КоординатыКорабля.Y = КоординатыЦели.Y Тогда 
		Y = 0;
	КонецЕсли;
	Если КоординатыКорабля.Z = КоординатыЦели.Z Тогда 
		Z = 0;
	КонецЕсли;
	
	Возврат НовыйВектор(X, Y, Z);
	
КонецФункции 

Функция КритичнаяТочкаДляКорабля(Корабль, Знач Точка) 
	
	Возврат ((Точка < 0) ИЛИ (Точка > РазмерКартыДляКорабля(Корабль)));
	
КонецФункции

Функция ПолучитьВекторУскоренияКТочке(Корабль, Координаты)
	КоординатыЦели			= НовыйВектор(Координаты);
	КорабльНаш 			    = КорабльНаш(Корабль);
	КоординатыКорабля 	    = ПолучитьВекторКоординатКорабля(Корабль);
	СкоростьКорабля		    = ПолучитьВекторСкоростиКорабля(Корабль);
	МаксимальноеУскорение   = ?(КорабльНаш, МаксимальноеУскорениеНашегоКорабля(Корабль), МаксимальноеУскорениеВражескогоКорабля(Корабль));
	РазмерКартыДляКорабля 	= РазмерКартыДляКорабля(Корабль);
	
	X_Цели = ?(КоординатыЦели.X > РазмерКартыДляКорабля , РазмерКартыДляКорабля , КоординатыЦели.X);
	X_Цели = ?(X_Цели < 0  , 0 , X_Цели);
	Y_Цели = ?(КоординатыЦели.Y > РазмерКартыДляКорабля , РазмерКартыДляКорабля , КоординатыЦели.Y);
	Y_Цели = ?(Y_Цели < 0  , 0  , Y_Цели);
	Z_Цели = ?(КоординатыЦели.Z > РазмерКартыДляКорабля , РазмерКартыДляКорабля , КоординатыЦели.Z);
	Z_Цели = ?(Z_Цели < 0  , 0  , Z_Цели);
	
	X = Неопределено;
	Y = Неопределено;
	Z = Неопределено;
	
	ВекторУскорения = ПолучитьВекторУскорения(Корабль, КоординатыЦели);
	
	i = - МаксимальноеУскорение ;
	
	Пока i <= МаксимальноеУскорение Цикл
		
		Координата_X = МинимальнаяКонечнаяКоординатаТормозногоПути(КоординатыКорабля.X + СкоростьКорабля.X + ВекторУскорения.X * i, СкоростьКорабля.X + ВекторУскорения.X * i, МаксимальноеУскорение);
		Координата_Y = МинимальнаяКонечнаяКоординатаТормозногоПути(КоординатыКорабля.Y + СкоростьКорабля.Y + ВекторУскорения.Y * i, СкоростьКорабля.Y + ВекторУскорения.Y * i, МаксимальноеУскорение);
		Координата_Z = МинимальнаяКонечнаяКоординатаТормозногоПути(КоординатыКорабля.Z + СкоростьКорабля.Z + ВекторУскорения.Z * i, СкоростьКорабля.Z + ВекторУскорения.Z * i, МаксимальноеУскорение);
		
		Если (КоординатыКорабля.X > X_Цели И Координата_X > X_Цели)
			ИЛИ (КоординатыКорабля.X < X_Цели И Координата_X < X_Цели) Тогда
			
			X = ВекторУскорения.X * i;
		КонецЕсли;
		Если (КоординатыКорабля.Y > Y_Цели И Координата_Y > Y_Цели)
			ИЛИ (КоординатыКорабля.Y < Y_Цели И Координата_Y < Y_Цели) Тогда
			
			Y = ВекторУскорения.Y * i;
		КонецЕсли;
		Если (КоординатыКорабля.Z > Z_Цели И Координата_Z > Z_Цели)
			ИЛИ (КоординатыКорабля.Z > Z_Цели И Координата_Z > Z_Цели) Тогда
			Z = ВекторУскорения.Z * i;
		КонецЕсли;
		
		Если Координата_X = X_Цели  Тогда
			X = ВекторУскорения.X * i;
		КонецЕсли;
		Если  Координата_Y = Y_Цели Тогда
			Y = ВекторУскорения.Y * i;
		КонецЕсли;
		Если  Координата_Z = Z_Цели Тогда
			Z = ВекторУскорения.Z * i;
		КонецЕсли;
		
		i = i + 1;
	КонецЦикла;
	
	ВекторМаксимальногоТорможения = ПолучитьВекторМаксимальногоТорможения(Корабль);
	
	X = ?(X = Неопределено , ВекторМаксимальногоТорможения.X, X);
	Y = ?(Y = Неопределено , ВекторМаксимальногоТорможения.Y, Y);
	Z = ?(Z = Неопределено , ВекторМаксимальногоТорможения.Z, Z);
	
	Возврат НовыйВектор(X,Y,Z);
	
КонецФункции


Функция ПолучитьМаксимальныйВекторУскорения(Корабль, Координаты)
	
	КоординатыЦели			= НовыйВектор(Координаты);
	КорабльНаш 			    = КорабльНаш(Корабль);
	КоординатыКорабля 	    = ПолучитьВекторКоординатКорабля(Корабль);
	Скорость		    	= ПолучитьВекторСкоростиКорабля(Корабль);
	МаксимальноеУскорениеКорабля   = ?(КорабльНаш = Истина, МаксимальноеУскорениеНашегоКорабля(Корабль), МаксимальноеУскорениеВражескогоКорабля(Корабль));
	
	X = Неопределено;
	Y = Неопределено;
	Z = Неопределено;
	
	ВекторУскорения = ПолучитьВекторУскорения(Корабль, КоординатыЦели);
	
	i = - МаксимальноеУскорениеКорабля;
	
	Пока i <= МаксимальноеУскорениеКорабля Цикл 
		
		X_Конца = МинимальнаяКонечнаяКоординатаТормозногоПути(КоординатыКорабля.X + Скорость.X + ВекторУскорения.X * i, Скорость.X + ВекторУскорения.X * i, МаксимальноеУскорениеКорабля);
		Y_Конца = МинимальнаяКонечнаяКоординатаТормозногоПути(КоординатыКорабля.Y + Скорость.Y + ВекторУскорения.Y * i, Скорость.Y + ВекторУскорения.Y * i, МаксимальноеУскорениеКорабля);
		Z_Конца = МинимальнаяКонечнаяКоординатаТормозногоПути(КоординатыКорабля.Z + Скорость.Z + ВекторУскорения.Z * i, Скорость.Z + ВекторУскорения.Z * i, МаксимальноеУскорениеКорабля);
		
		Если НЕ КритичнаяТочкаДляКорабля(Корабль, X_Конца) Тогда
			X = ВекторУскорения.X * i;
		КонецЕсли;
		Если НЕ КритичнаяТочкаДляКорабля(Корабль, Y_Конца) Тогда
			Y = ВекторУскорения.Y * i;
		КонецЕсли;
		Если НЕ КритичнаяТочкаДляКорабля(Корабль, Z_Конца) Тогда
			Z = ВекторУскорения.Z * i;
		КонецЕсли;
		
		i = i + 1;
	КонецЦикла;
	
	ВекторМаксимальногоТорможения = ПолучитьВекторМаксимальногоТорможения(Корабль);
	
	X = ?(X = Неопределено , ВекторМаксимальногоТорможения.X, X);
	Y = ?(Y = Неопределено , ВекторМаксимальногоТорможения.Y, Y);
	Z = ?(Z = Неопределено , ВекторМаксимальногоТорможения.Z, Z);
	
	Возврат НовыйВектор(X,Y,Z);
	
КонецФункции

Функция ПолучитьВекторМаксимальногоТорможения(Корабль)
	КорабльНаш 			    = КорабльНаш(Корабль);
	Скорость		    	= ПолучитьВекторСкоростиКорабля(Корабль);
	МаксимальноеУскорениеКорабля   = ?(КорабльНаш = Истина, МаксимальноеУскорениеНашегоКорабля(Корабль), МаксимальноеУскорениеВражескогоКорабля(Корабль));
	
	X = ?(Скорость.X > 0 , -МаксимальноеУскорениеКорабля , МаксимальноеУскорениеКорабля); 
	Y = ?(Скорость.Y > 0 , -МаксимальноеУскорениеКорабля , МаксимальноеУскорениеКорабля); 
	Z = ?(Скорость.Z > 0 , -МаксимальноеУскорениеКорабля , МаксимальноеУскорениеКорабля); 
	
	Возврат НовыйВектор(X, Y, Z);
КонецФункции 

Функция ПолучитьВекторДляОстановкиКорабля(Корабль)
	КорабльНаш 			    = КорабльНаш(Корабль);
	КоординатыКорабля 	    = ПолучитьВекторКоординатКорабля(Корабль);
	Скорость		    	= ПолучитьВекторСкоростиКорабля(Корабль);
	МаксимальноеУскорениеКорабля   = ?(КорабльНаш, МаксимальноеУскорениеНашегоКорабля(Корабль), МаксимальноеУскорениеВражескогоКорабля(Корабль));
	
	X = Неопределено;
	Y = Неопределено;
	Z = Неопределено;
	
	i = - МаксимальноеУскорениеКорабля ;
	
	Пока i <= МаксимальноеУскорениеКорабля Цикл 
		
		Если Скорость.X + i = 0 Тогда 
			X = i;
		КонецЕсли;
		Если Скорость.Y + i = 0 Тогда 
			Y = i;
		КонецЕсли;
		Если Скорость.Z + i = 0 Тогда 
			Z = i;
		КонецЕсли;
		
		i= i + 1 ;
	КонецЦикла;
	
	ВекторМаксимальногоТорможения = ПолучитьВекторМаксимальногоТорможения(Корабль);
	
	X = ?(X = Неопределено , ВекторМаксимальногоТорможения.X, X) ;
	Y = ?(Y = Неопределено , ВекторМаксимальногоТорможения.Y, Y) ;
	Z = ?(Z = Неопределено , ВекторМаксимальногоТорможения.Z, Z) ;	
	
	Возврат НовыйВектор(X, Y, Z);
	
КонецФункции

Функция Летим(Корабль, Координаты, Максимально = Ложь)
	
	КоординатыЦели			= НовыйВектор(Координаты);
	КорабльНаш 			    = КорабльНаш(Корабль);
	КоординатыКорабля 	    = ПолучитьВекторКоординатКорабля(Корабль);
	Скорость		    	= ПолучитьВекторСкоростиКорабля(Корабль);
	МаксимальноеУскорениеКорабля   = ?(КорабльНаш, МаксимальноеУскорениеНашегоКорабля(Корабль), МаксимальноеУскорениеВражескогоКорабля(Корабль));
	
	Если Максимально = Ложь Тогда
		ВекторУскорения = ПолучитьВекторУскоренияКТочке(Корабль, КоординатыЦели);
	Иначе 
		ВекторУскорения = ПолучитьМаксимальныйВекторУскорения(Корабль, КоординатыЦели);
	КонецЕсли;
	
	ДобавитьКоманду(Ускорение(Корабль, ВекторУскорения));
	
КонецФункции

Функция КоординатыКораблей()
	
	// Функция возвращает все кординаты всех кораблей союзников
	// TODO подумать над результатом как соответствие
	
	КоординатыКораблей = Новый Массив;
	
	Для Каждого Корабль Из Корабли Цикл		
		
		ПозицияКорабля    = ПозицияКорабля(Корабль);
		КоординатыКорабля = МассивКоординатКорабля(ПозицияКорабля, Истина);
		
		Для Каждого Элемент Из КоординатыКорабля Цикл
			КоординатыКораблей.Добавить(Элемент);
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат КоординатыКораблей; 
	
КонецФункции

Функция КоординатыКораблейПротивников()
	
	// Функция возвращает все кординаты всех кораблей противников
	// TODO подумать над результатом как соответствие
	
	КоординатыКораблей = Новый Массив;
	
	Для Каждого Корабль Из КораблиПротивника Цикл
		
		ПозицияКорабля    = ПозицияКорабля(Корабль);
		КоординатыКорабля = МассивКоординатКорабля(ПозицияКорабля, Истина);
		
		Для Каждого Элемент Из КоординатыКорабля Цикл
			КоординатыКораблей.Добавить(Элемент);
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат КоординатыКораблей; 	
	
КонецФункции

#КонецОбласти

/////////////////////////////////////////////////////
// Команды

#Область Команды

Процедура ДобавитьКоманду(Команда)
	
	Если Команда = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если Ответ["UserCommands"] = Неопределено Тогда
		Ответ.Вставить("UserCommands", Новый Массив());
	КонецЕсли;
	
	Ответ["UserCommands"].Добавить(Команда);
	
КонецПроцедуры

Функция Автопилот(КлассКорабль, Цель)
	
	Результат = Новый Структура();
	Результат.Вставить("Command"	, "MOVE");
	Результат.Вставить("Parameters" , НовыйПараметрыАвтопилота(КлассКорабль, Цель));
	
	Возврат Результат;
	
КонецФункции

Функция Ускорение(Корабль, Вектор)
	
	Результат = Новый Структура();
	Результат.Вставить("Command"	, "ACCELERATE");
	Результат.Вставить("Parameters" , НовыйПараметрыУскорения(Корабль, Вектор));
	
	Возврат Результат;
	
КонецФункции

Функция Выстрел(Корабль, Цель, Орудие = Неопределено)
	
	Если Орудие = Неопределено Тогда
		Орудие = ОсновноеОрудиеКорабля(Корабль);
	КонецЕсли;
	
	Результат = Новый Структура();
	Результат.Вставить("Command"	, "ATTACK");
	Результат.Вставить("Parameters" , НовыйПараметрыВыстрела(Корабль, Орудие, Цель));
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

/////////////////////////////////////////////////////
// Сущности

#Область Сущности

Функция НовыйВектор(Знач x, Знач y = Неопределено, Знач z = Неопределено)
	
	Вектор = Новый Структура("x, y, z", 0,0,0);
	
	Если ТипЗнч(x) = Тип("Строка") Тогда
		
		ВекторСтрока    = x;
		ЭлементыВектора = Новый Массив;
		
		Для Сч = 1 По 3 Цикл
			Разделитель   = Найти(ВекторСтрока, "/");
			Если Разделитель = 0 Тогда
				ЭлементыВектора.Добавить(ВекторСтрока);
				Прервать;
			КонецЕсли;
			ЭлементВектора = Лев(ВекторСтрока, Разделитель - 1);
			ЭлементыВектора.Добавить(ЭлементВектора);
			ВекторСтрока = Сред(ВекторСтрока, Разделитель + 1)
		КонецЦикла;
		
		Если ЭлементыВектора.Количество() = 3 Тогда
			Вектор.x = Число(ЭлементыВектора[0]);
			Вектор.y = Число(ЭлементыВектора[1]);
			Вектор.z = Число(ЭлементыВектора[2]);
		КонецЕсли
		
	ИначеЕсли ТипЗнч(x) = Тип("Структура") Тогда
		
		Возврат x;
		
	Иначе
		
		Вектор.x = x;
		Вектор.y = y;
		Вектор.z = z;
		
	КонецЕсли;
	
	Возврат Вектор;
	
КонецФункции

Функция ВекторСтрокой(Вектор)
	
	Если ТипЗнч(Вектор) = Тип("Строка") Тогда
		Возврат Вектор;
	КонецЕсли;
	
	Возврат СтрШаблон("%1/%2/%3", Вектор.x, Вектор.y, Вектор.z); 
	
КонецФункции

Функция НовыйПараметрыУскорения(Корабль, Вектор)
	
	ПараметрыАвтопилота = Новый Структура;
	ПараметрыАвтопилота.Вставить("Id"	 , Корабль["Id"]); 
	ПараметрыАвтопилота.Вставить("Vector", ВекторСтрокой(Вектор));
	
	Возврат ПараметрыАвтопилота;
	
КонецФункции

Функция НовыйПараметрыАвтопилота(Корабль, Вектор)
	
	ПараметрыАвтопилота = Новый Структура;
	ПараметрыАвтопилота.Вставить("Id"	 , Корабль["Id"]); 
	ПараметрыАвтопилота.Вставить("Target", ВекторСтрокой(Вектор));
	
	Возврат ПараметрыАвтопилота;
	
КонецФункции

Функция НовыйПараметрыВыстрела(Корабль, Орудие, Цель)
	
	ПараметрыВыстрела = Новый Структура;
	ПараметрыВыстрела.Вставить("Id"		, Корабль["Id"]);
	ПараметрыВыстрела.Вставить("Name"	, Орудие["Name"]);
	ПараметрыВыстрела.Вставить("Target"	, ВекторСтрокой(Цель));
	
	Возврат ПараметрыВыстрела;
	
КонецФункции

Функция НовыйОтвет()
	
	Ответ = Новый Соответствие;
	Ответ.Вставить("UserCommands", Новый Массив);
	Ответ.Вставить("Message"     , "");
	
	Возврат Ответ;
	
КонецФункции

#КонецОбласти

/////////////////////////////////////////////////////
// Вычисления

#Область Вычисления

Функция РасстояниеЧебышев(Знач Позиция1, Знач Позиция2)
	
	Если ТипЗнч(Позиция1) = Тип("Строка") Тогда
		Позиция1 = НовыйВектор(Позиция1);
	КонецЕсли;
	
	Если ТипЗнч(Позиция2) = Тип("Строка") Тогда
		Позиция2 = НовыйВектор(Позиция2);
	КонецЕсли;
	
	РасстояниеX = МодульЧисла(Позиция2.X - Позиция1.X);
	РасстояниеY = МодульЧисла(Позиция2.Y - Позиция1.Y);
	РасстояниеZ	= МодульЧисла(Позиция2.Z - Позиция1.Z);
	
	Расстояние = Макс(РасстояниеX, РасстояниеY, РасстояниеZ); 
	
	Возврат Расстояние
	
КонецФункции

Функция МодульВектора(Знач Вектор)
	
	Если ТипЗнч(Вектор) = Тип("Строка") Тогда
		Вектор = НовыйВектор(Вектор);
	КонецЕсли;
	
	Возврат Макс(
	МодульЧисла(Вектор.X), 
	МодульЧисла(Вектор.Y), 
	МодульЧисла(Вектор.Z));
	
КонецФункции

Функция МодульЧисла(Значение)
	
	Возврат Макс(Значение, - Значение);
	
КонецФункции

Функция СуммаВекторов(Знач Вектор1, Знач Вектор2)
	
	Вектор1 = НовыйВектор(Вектор1);
	Вектор2 = НовыйВектор(Вектор2);
	
	Возврат НовыйВектор(
	Вектор1.X + Вектор2.X, 
	Вектор1.Y + Вектор2.Y, 
	Вектор1.Z + Вектор2.Z);
	
КонецФункции

#КонецОбласти

/////////////////////////////////////////////////////
// Служебные процедуры и функции

#Область СлужебныеПроцедурыиФункции

Процедура ЦиклЖизни(ТестовыеАргументы = Неопределено)
	
	Пока Истина Цикл
		
		Если ТестовыеАргументы = Неопределено Тогда
			
			// Входящий поток
			
			ВходныеДанные  = Консоль.ПрочитатьСтроку();
			ВыходнойФайл = Неопределено;
			
		Иначе
			
			// Отладка через файл
			
			ВходнойФайл = ТестовыеАргументы[0];
			ВыходнойФайл = ТестовыеАргументы[1];
			Чтение = Новый ЧтениеТекста(ВходнойФайл);
			ВходныеДанные = Чтение.Прочитать();
			Чтение.Закрыть();
			
		КонецЕсли;
		
		Если НЕ ЗначениеЗаполнено(ВходныеДанные) Тогда
			Продолжить;
		КонецЕсли;
		
		Попытка
			
			Состояние = ПарсерJSON.ПрочитатьJSON(ВходныеДанные);

			ИнициализироватьОкружение(ВходныеДанные);

			Если ЭтоДрафт Тогда
				ВыполнитьСценарийДрафт();
			Иначе
				ВыполнитьСценарий();
			КонецЕсли;

		Исключение
			
			ОписаниеОшибки = ОписаниеОшибки();
			ПодготовитьОтветОписаниеОшибки(ОписаниеОшибки);		
			
		КонецПопытки;
		
		ВывестиВалидныйОтвет(ВыходнойФайл);
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ИнициализироватьОкружение(ВходныеДанные)
	
	// Служебные
	
	НомерИтерации  = НомерИтерации + 1;
	НачалоИтерации = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	// Новые
	
	Ответ   = НовыйОтвет();
	
	// Представления

	Корабли 		  = Состояние["My"];
	КораблиПротивника = Состояние["Opponent"]; 	

	ЭтоДрафт = Состояние["MapSize"] <> Неопределено;

	Если ЭтоДрафт Тогда
		РазмерКарты = Состояние["MapSize"];
	Иначе
		// Для отладки
		Если РазмерКарты = Неопределено Тогда
			РазмерКарты = 30;
		КонецЕсли	
	КонецЕсли;

КонецПроцедуры

Процедура ВывестиВалидныйОтвет(ТестовыйФайл = Неопределено)
	
	МаксимальнаяДлинаСообщения = 2000;
	
	ВалидныйОтветСтрока = ПарсерJSON.записатьJSON(Ответ);
	ВалидныйОтветСтрока = СтрЗаменить(ВалидныйОтветСтрока, Символы.ПС, "");
	ВалидныйОтветСтрока = СтрЗаменить(ВалидныйОтветСтрока, " ", "");
	
	КонецИтерации = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИтерацияВМиллисекундах  = КонецИтерации - НачалоИтерации;	
	
	НачалоСообщения = """Message"":""";
	ОтладочноеСообщение = "in:" + НомерИтерации + ";it:" + Строка(ИтерацияВМиллисекундах) + ";";
	Для Каждого Элемент Из Отладка Цикл
		ОтладочноеСообщение = ОтладочноеСообщение + Элемент + ";";
	КонецЦикла;
	
	JSON = Новый Структура;
	JSON.Вставить("k", ОтладочноеСообщение);
	
	ЭкранированыйТекст = ПарсерJSON.записатьJSON(JSON);
	ЭкранированыйТекст = СтрЗаменить(ЭкранированыйТекст, Символы.ПС, "");
	ЭкранированыйТекст = СтрЗаменить(ЭкранированыйТекст, " ", "");
	
	ОтладочноеСообщение = Сред(ЭкранированыйТекст, 7, СтрДлина(ЭкранированыйТекст) - 8);
	
	// обработка отладночго сообщения
	
	ОтладочноеСообщение = СтрЗаменить(ОтладочноеСообщение, Символы.ПС, "");
	ОтладочноеСообщение = СтрЗаменить(ОтладочноеСообщение, " ", "");
	
	// попытка вставить сообщение
	
	ВалидныйОтветСтрокаССообщением = СтрЗаменить(ВалидныйОтветСтрока, НачалоСообщения, НачалоСообщения + ОтладочноеСообщение);
	ДлинаСообщения = СтрДлина(ВалидныйОтветСтрокаССообщением);
	
	Если ДлинаСообщения > МаксимальнаяДлинаСообщения Тогда
		
		ПревышениеДлины = ДлинаСообщения - МаксимальнаяДлинаСообщения;	
		ДлинаОтладочногоСообщения = СтрДлина(ОтладочноеСообщение);
		
		Если ДлинаОтладочногоСообщения >= ПревышениеДлины Тогда
			
			ОтладочноеСообщение 			= Лев(ОтладочноеСообщение, ДлинаОтладочногоСообщения - ПревышениеДлины);
			ВалидныйОтветСтрокаПослеОбрезки = СтрЗаменить(ВалидныйОтветСтрока, НачалоСообщения, НачалоСообщения + ОтладочноеСообщение);
			
			Если СтрДлина(ВалидныйОтветСтрокаПослеОбрезки) <= МаксимальнаяДлинаСообщения Тогда
				ВалидныйОтветСтрока = ВалидныйОтветСтрокаПослеОбрезки;
			КонецЕсли
		КонецЕсли;
		
	Иначе
		
		ВалидныйОтветСтрока = ВалидныйОтветСтрокаССообщением;
		
	КонецЕсли;
	
	Если ТестовыйФайл = Неопределено Тогда
		Консоль.ВывестиСтроку(ВалидныйОтветСтрока);
	Иначе
		Запись = Новый ЗаписьТекста(ТестовыйФайл);
		Запись.Записать(ВалидныйОтветСтрока);
		Запись.Закрыть();
	КонецЕсли	
	
КонецПроцедуры

Процедура ПодготовитьОтветОписаниеОшибки(ОписаниеОшибки)
	
	Ответ = Новый Соответствие();
	Ответ.Вставить("UserCommands", Новый Массив());
	Ответ.Вставить("Message"     , ТранслитироватьСтроку(ОписаниеОшибки));
	
КонецПроцедуры

Функция МассивСоответствийВТаблицуЗначений(Массив)
	
	Результат = Новый ТаблицаЗначений();
	Если Массив.Количество() = 0 Тогда
		Возврат Результат;
	КонецЕсли;
	
	//Считаем что все соответствия одинаковы по составу полей
	
	ПервоеСоответствие = Массив[0];
	Для Каждого Элемент Из ПервоеСоответствие Цикл
		Результат.Колонки.Добавить(Элемент.Ключ);
	КонецЦикла;
	Результат.Колонки.Добавить("ИзначальноеСоответствие");
	
	Для Каждого Соответстие Из Массив Цикл
		НоваяСтрока = Результат.Добавить();
		Для Каждого Колонка из Результат.Колонки Цикл
			Ключ = Колонка.Имя;
			НоваяСтрока[Ключ] = Соответстие[Ключ];
		КонецЦикла;
		НоваяСтрока.ИзначальноеСоответствие = Соответстие;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ТаблицаЗначенийВМассивСоответствий(Таблица)
	
	Результат = Новый Массив;
	
	СписокКолонок = "";
	Для Каждого Колонка из Таблица.Колонки Цикл
		СписокКолонок = СписокКолонок + ?(ПустаяСтрока(СписокКолонок), "", ", ") + Колонка.Имя;	
	КонецЦикла;
	
	Для Каждого Строка из Таблица Цикл
		Соответствие = Новый Соответствие();
		Для Каждого Колонка из Таблица.Колонки Цикл
			Соответствие.Вставить(Колонка.Имя, Строка[Колонка.Имя]);
		КонецЦикла;
		Результат.Добавить(Соответствие);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ТранслитироватьСтроку(Знач Строка)
	
	Для Каждого Элемент Из ПравилоТранслитерации() Цикл
		Строка = СтрЗаменить(Строка, Элемент.Ключ, Элемент.Значение);
		Строка = СтрЗаменить(Строка, ВРег(Элемент.Ключ), ВРег(Элемент.Значение));
	КонецЦикла;
	
	Возврат Строка;
	
КонецФункции

Функция ПравилоТранслитерации()
	
	ПравилоТранслитерации = Новый Соответствие;
	ПравилоТранслитерации.Вставить("а", "a");	
	ПравилоТранслитерации.Вставить("б", "b");
	ПравилоТранслитерации.Вставить("в", "v");
	ПравилоТранслитерации.Вставить("г", "g");
	ПравилоТранслитерации.Вставить("д", "d");
	ПравилоТранслитерации.Вставить("е", "e");
	ПравилоТранслитерации.Вставить("ё", "e");
	ПравилоТранслитерации.Вставить("ж", "zh");
	ПравилоТранслитерации.Вставить("з", "z");
	ПравилоТранслитерации.Вставить("и", "i");
	ПравилоТранслитерации.Вставить("й", "y");
	ПравилоТранслитерации.Вставить("к", "k");
	ПравилоТранслитерации.Вставить("л", "l");
	ПравилоТранслитерации.Вставить("м", "m");
	ПравилоТранслитерации.Вставить("н", "n");
	ПравилоТранслитерации.Вставить("о", "o");
	ПравилоТранслитерации.Вставить("п", "p");
	ПравилоТранслитерации.Вставить("р", "r");
	ПравилоТранслитерации.Вставить("с", "s");
	ПравилоТранслитерации.Вставить("т", "t");
	ПравилоТранслитерации.Вставить("у", "u");
	ПравилоТранслитерации.Вставить("ф", "f");
	ПравилоТранслитерации.Вставить("х", "h");
	ПравилоТранслитерации.Вставить("ц", "c");
	ПравилоТранслитерации.Вставить("ч", "ch");
	ПравилоТранслитерации.Вставить("ш", "sh");
	ПравилоТранслитерации.Вставить("щ", "shch");
	ПравилоТранслитерации.Вставить("ъ", "");
	ПравилоТранслитерации.Вставить("ы", "y");
	ПравилоТранслитерации.Вставить("ь", "");
	ПравилоТранслитерации.Вставить("э", "e");
	ПравилоТранслитерации.Вставить("ю", "yu");
	ПравилоТранслитерации.Вставить("я", "ya");
	
	Возврат ПравилоТранслитерации;
	
КонецФункции

#КонецОбласти

/////////////////////////////////////////////////////
// Основная программа

Консоль       = Новый Консоль();
ПарсерJSON    = Новый ПарсерJSON();
НомерИтерации = 0;
ЭтоДрафт	  = Ложь;

Если АргументыКоманднойСтроки.Количество() > 0 Тогда
	
	ЦиклЖизни(АргументыКоманднойСтроки);
	
Иначе
	
	ЦиклЖизни();
	
КонецЕсли